/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 ./public/models/chess/chess_set_2k.gltf 
*/
"use client";

import React, { Fragment, useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { Color, Group, Mesh, Vector3 } from "three";
import { Chess, Move, PieceSymbol, Square } from "chess.js";
import { motion } from "framer-motion-3d";
import {
  BoardPieces,
  convertIndexArrayToPositionArray,
  convertIndexesToPosition,
  convertPositionNumbersToObject,
  convertPositionToSquare,
  equalizePositions,
  getActivePiece,
  PieceOptions,
  PieceStateOptions,
} from "@/utils/helpers";
import { ThreeEvent, useFrame } from "@react-three/fiber";
import Board from "./Board";
import { PositionsType } from "@/utils/types";
import { positions, xPositions, yPositions } from "@/utils/constants";
import Pawn from "./Pawn";
import Rook from "./Rook";
import Knight from "./Knight";
import Bishop from "./Bishop";
import King from "./King";
import Queen from "./Queen";

export type Board = ({
  square: Square;
  type: PieceSymbol;
  color: string;
} | null)[][];

export type PositionBoard = {
  board: {
    square: Square;
    type: PieceSymbol;
    color: string;
  } | null;
  position: [x: number, y: number, z: number];
}[];

export default function Model() {
  const modelRef = useRef<Group>(null!);
  const chessState = new Chess();
  const [chessArray, setChessArray] = useState<PositionBoard>(
    convertIndexArrayToPositionArray(chessState.board().reverse())
  );
  console.log(chessArray);

  const [isReady, setIsReady] = useState(false);
  const [currPlayer, setCurrPlayer] = useState<"white" | "black">("white");
  const [activeSpots, setActiveSpots] = useState<Move[]>([]);
  const [activeSquare, setActiveSquare] = useState<string>("");
  useEffect(() => {
    if (modelRef.current) {
      modelRef.current.rotation.y = Math.PI;
      setIsReady(true);
    }
  }, []);
  const { nodes, materials } = useGLTF(
    "/models/chess/chess_set_2k.gltf"
  ) as any;

  useEffect(() => {
    if (!isReady) return;
    setChessArray(
      convertIndexArrayToPositionArray(chessState.board().reverse())
    );
  }, [isReady]);

  const checkWinner = () => {
    if (chessState.isGameOver()) {
      if (chessState.isCheckmate()) {
        const winner = chessState.turn() === "w" ? "Black" : "White";
        console.log(winner + " wins by checkmate");
      } else if (chessState.isDraw()) {
        console.log("Draw");
      } else if (chessState.isInsufficientMaterial()) {
        console.log("Draw");
      } else if (chessState.isStalemate()) {
        console.log("Draw");
      } else if (chessState.isThreefoldRepetition()) {
        console.log("Draw");
      } else {
        console.log("Game over due to other reasons");
      }
    }
  };

  const handleClickPiece = (e: ThreeEvent<MouseEvent>) => {
    const square = convertPositionToSquare(e.eventObject.position);
    if (!square) {
      console.log("error:", "Cannot get square position");
      return;
    }
    const possibleMoves = chessState.moves({ square, verbose: true });
    console.log(possibleMoves);
    const positionCheck = possibleMoves.find((fnd) => fnd.to === square);
    if (activeSquare === square) {
      setActiveSpots([]);
      setActiveSquare("");
    } else if (positionCheck) {
      return;
    } else {
      setActiveSpots(possibleMoves);
      setActiveSquare(square);
    }
  };

  const handleClickBoard = (e: ThreeEvent<MouseEvent>) => {
    const square = convertPositionToSquare(e.eventObject.position);
    if (!square) return;
    if (!chessState) return;
    const activeCheck = activeSpots.find((filt) => square === filt.to);

    if (!activeCheck || square === activeSquare) return;

    chessState.move(activeCheck);
    console.log(activeCheck);
    clearActiveSpots();
    // setChessArray(
    //   convertIndexArrayToPositionArray(chessState.board().reverse())
    // );
    const changedPositionsIndex: number[] = [];

    chessArray.forEach((first, i) => {
      convertIndexArrayToPositionArray(chessState.board().reverse()).forEach(
        (second, j) => {
          if (i === j) {
            if (
              second.board?.color !== first.board?.color &&
              second.board?.type !== first.board?.type
            ) {
              changedPositionsIndex.push(j);
            }
          }
        }
      );
    });
    console.log(changedPositionsIndex);
    // setChessArray((prev) => {
    //   return prev.map((obj, i) => {
    //     if (changedPositionsIndex.includes(i)) {
    //       // return {
    //       //   ...obj,
    //       //   position: convertIndexArrayToPositionArray(
    //       //     chessState.board().reverse()
    //       //   )[i].position,
    //       // };
    //       console.log(
    //         convertIndexArrayToPositionArray(chessState.board().reverse())[i]
    //       );
    //       return { ...obj };
    //     } else return { ...obj };
    //   });
    // });
    checkWinner();
  };

  const clearActiveSpots = () => {
    setActiveSpots([]);
    setActiveSquare("");
  };

  return (
    <group dispose={null} ref={modelRef}>
      <group position={[0, 0, 0]}>
        <Board
          activeSpots={activeSpots}
          activeSquare={activeSquare}
          handleClickBoard={handleClickBoard}
        />
        {chessArray.map((chess, i) => {
          return (
            <group key={i}>
              {chess?.board?.type === "p" && (
                <Pawn
                  color={chess?.board.color}
                  nodes={nodes}
                  materials={materials}
                  position={chess.position}
                  handleClick={handleClickPiece}
                />
              )}
              {chess?.board?.type === "r" && (
                <Rook
                  color={chess?.board.color}
                  nodes={nodes}
                  materials={materials}
                  position={chess.position}
                  handleClick={handleClickPiece}
                />
              )}
              {chess?.board?.type === "n" && (
                <Knight
                  color={chess?.board.color}
                  nodes={nodes}
                  materials={materials}
                  position={chess.position}
                  handleClick={handleClickPiece}
                />
              )}
              {chess?.board?.type === "b" && (
                <Bishop
                  color={chess?.board.color}
                  nodes={nodes}
                  materials={materials}
                  position={chess.position}
                  handleClick={handleClickPiece}
                />
              )}
              {chess?.board?.type === "k" && (
                <King
                  color={chess?.board.color}
                  nodes={nodes}
                  materials={materials}
                  position={chess.position}
                  handleClick={handleClickPiece}
                />
              )}
              {chess?.board?.type === "q" && (
                <Queen
                  color={chess?.board.color}
                  nodes={nodes}
                  materials={materials}
                  position={chess.position}
                  handleClick={handleClickPiece}
                />
              )}
            </group>
          );
        })}
      </group>
    </group>
  );
}

useGLTF.preload("/chess_set_2k.gltf");
